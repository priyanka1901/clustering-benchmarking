---
title: "Clustering Non-Convex Datasets: A Comparative Study Across Hard, Soft, Model-Based, Spectral, and Density-Based Methods."
author: "Priyanka Goel"
date: "2025-04-26"
output: html_document
---

**Motivation:**

In real-world scenarios, clusters are rarely convex or spherical. Classical methods like k-means fail for non-convex shapes.

**Goal:**

Compare performance of five clustering algorithms on synthetic non-convex datasets. Understand where each algorithm excels and where it struggles.

# Setup

```{r}
# Loading all the required libraries
library(MASS)
library(mclust)
library(kernlab)
library(FPDclustering)
library(dbscan)
library(fclust)
library(cluster)
library(factoextra)
library(MixGHD)      
library(aricode)
library(clusterCrit)
library(ggplot2)
library(FNN) 
library(Rtsne)
```

```{r}
# Create empty lists to store datasets
datasets_data1 <- list()
datasets_data2 <- list()
datasets_data3 <- list()
datasets_data4 <- list()
```

```{r}
# Number of repetitions
n_reps <- 20
```

# Simulating Datasets for 3 clusters

## Dataset 1: Well-separated spherical clusters

We generate 3 clusters from bivariate normal distributions with different means and identical variances

```{r}

for (i in 1:n_reps) {
  repeat{
  n <- 200
  p <- 2
  mu1 <- c(0, 0)
  mu2 <- c(3, 3)
  mu3 <- c(5, 0)
  Sigma <- diag(2) * 0.5
  
  cluster1 <- mvrnorm(n, mu1, Sigma)
  cluster2 <- mvrnorm(n, mu2, Sigma)
  cluster3 <- mvrnorm(n, mu3, Sigma)
  
  X_data1 <- rbind(cluster1, cluster2, cluster3)
  true_labels_data1 <- factor(rep(1:3, each = n))
  
  # Check if dataset is clean
    if (any(!is.finite(as.matrix(X_data1))) || any(is.na(as.matrix(X_data1))) || any(is.nan(as.matrix(X_data1)))) {
      warning(paste("Non-finite values detected in Well-separated spherical dataset run", i, "- regenerating"))
      next  # Retry this iteration
    }
  
  X_data1 <- as.data.frame(X_data1)
  colnames(X_data1) <- c("X1", "X2")

  X_data1$X1 <- pmin(pmax(X_data1$X1, -1e6), 1e6)
  X_data1$X2 <- pmin(pmax(X_data1$X2, -1e6), 1e6)
  
  
  break 
  
  }
  
  datasets_data1[[i]] <- list(X = X_data1, labels = true_labels_data1)
}

plot(datasets_data1[[1]]$X, col = datasets_data1[[1]]$labels, pch = 19, main = "Well-separated spherical clusters")
```

## Dataset 2: Overlapping spherical clusters

We generate 3 bivariate normal clusters with higher variance and means that are closer together than the clusters from Dataset 1

```{r}
for (i in 1:n_reps) {
  repeat{
  n <- 200
  p <- 2
  mu1 <- c(2, 2)
  mu2 <- c(5, 3)
  mu3 <- c(3, 5)
  Sigma <- diag(2) * 1.2
  
  cluster1 <- mvrnorm(n, mu1, Sigma)
  cluster2 <- mvrnorm(n, mu2, Sigma)
  cluster3 <- mvrnorm(n, mu3, Sigma)
  
  X_data2 <- rbind(cluster1, cluster2, cluster3)
  true_labels_data2 <- factor(rep(1:3, each = n))
  
  # Check if dataset is clean
    if (any(!is.finite(as.matrix(X_data2))) || any(is.na(as.matrix(X_data2))) || any(is.nan(as.matrix(X_data2)))) {
      warning(paste("Non-finite values detected in overlapping spherical dataset run", i, "- regenerating"))
      next  # Retry this iteration
    }
  
  X_data2 <- as.data.frame(X_data2)
  colnames(X_data2) <- c("X1", "X2")

  X_data2$X1 <- pmin(pmax(X_data2$X1, -1e6), 1e6)
  X_data2$X2 <- pmin(pmax(X_data2$X2, -1e6), 1e6)
  
  
  break 
  
  }
  
  datasets_data2[[i]] <- list(X = X_data2, labels = true_labels_data2)
}

plot(datasets_data2[[1]]$X, col = datasets_data2[[1]]$labels, pch = 19, main = "Overlapping spherical clusters")
```

## Dataset 3: Moons + shifted blob (non-convex + convex)

We generate 3 clusters; one from a bivariate normal, which we call the blob, and two others generated by adding random noise to portions of sinusoids, which we call moons.

```{r}
for (i in 1:n_reps) {
  repeat{
  n_core <- 200
  n_outliers_per_cluster <- 3
  theta <- runif(n_core, 0, pi)
  
  # Moon 1
  x1 <- cos(theta) + rnorm(n_core, sd = 0.05)
  y1 <- sin(theta) + rnorm(n_core, sd = 0.05)
  moon1_core <- cbind(x1, y1)
  
  theta_out1 <- runif(n_outliers_per_cluster, 0, pi)
  x1_out <- cos(theta_out1) * 2 + rnorm(n_outliers_per_cluster, sd = 0.2)
  y1_out <- sin(theta_out1) * 2 + rnorm(n_outliers_per_cluster, sd = 0.2)
  moon1_outliers <- cbind(x1_out, y1_out)
  
  # Moon 2
  x2 <- 1 - cos(theta) + rnorm(n_core, sd = 0.05)
  y2 <- -sin(theta) - 0.3 + rnorm(n_core, sd = 0.05)
  moon2_core <- cbind(x2, y2)
  
  theta_out2 <- runif(n_outliers_per_cluster, 0, pi)
  x2_out <- (1 - cos(theta_out2)) * 2 + rnorm(n_outliers_per_cluster, sd = 0.2)
  y2_out <- (-sin(theta_out2) - 0.3) * 2 + rnorm(n_outliers_per_cluster, sd = 0.2)
  moon2_outliers <- cbind(x2_out, y2_out)
  
  # Circle blob
  circle_center <- c(3, 2)
  circle_core <- mvrnorm(n_core, mu = circle_center, Sigma = diag(2) * 0.1)
  circle_outliers <- mvrnorm(n_outliers_per_cluster, mu = circle_center + c(0.5, 0.5), Sigma = diag(2) * 0.1)
  
  # Combine all
  X <- rbind(
    moon1_core,
    moon2_core,
    circle_core,
    moon1_outliers,
    moon2_outliers,
    circle_outliers
  )
  
  labels <- factor(c(
    rep(1, n_core + n_outliers_per_cluster),
    rep(2, n_core + n_outliers_per_cluster),
    rep(3, n_core + n_outliers_per_cluster)
  ))
  
  # Check if dataset is clean
    if (any(!is.finite(as.matrix(X))) || any(is.na(as.matrix(X))) || any(is.nan(as.matrix(X)))) {
      warning(paste("Non-finite values detected in moons + shifted blob dataset run", i, "- regenerating"))
      next  # Retry this iteration
    }
  
  X <- as.data.frame(X)
  colnames(X) <- c("X1", "X2")

  X$X1 <- pmin(pmax(X$X1, -1e6), 1e6)
  X$X2 <- pmin(pmax(X$X2, -1e6), 1e6)
  
  
  break 
  
  }
  
  datasets_data3[[i]] <- list(X = X, labels = labels)
}

plot(datasets_data3[[1]]$X, col = datasets_data3[[1]]$labels, pch = 19, main = "Moons + shifted blob (non-convex + convex)")
```

## Dataset 4: Two concentric circles

We generate circular data at different radii to form two concentric circles. Because these are overlapping non-convex shapes we expect very poor performance when using centroid based algorithms.

```{r}
for (i in 1:n_reps) {
  repeat{
  n <- 300  # points per circle
  
  # Circle 1 (smaller)
  theta1 <- runif(n, 0, 2*pi)
  r1 <- 1
  x1 <- r1 * cos(theta1) + rnorm(n, 0, 0.05)
  y1 <- r1 * sin(theta1) + rnorm(n, 0, 0.05)
  
  # Circle 2 (larger)
  theta2 <- runif(n, 0, 2*pi)
  r2 <- 2
  x2 <- r2 * cos(theta2) + rnorm(n, 0, 0.05)
  y2 <- r2 * sin(theta2) + rnorm(n, 0, 0.05)
  
  X_data4 <- data.frame(X1 = c(x1, x2), X2 = c(y1, y2))
  true_labels_data4 <- factor(c(rep(1, n), rep(2, n)))
  
  # Check if dataset is clean
    if (any(!is.finite(as.matrix(X_data4))) || any(is.na(as.matrix(X_data4))) || any(is.nan(as.matrix(X_data4)))) {
      warning(paste("Non-finite values detected in concentric circles dataset run", i, "- regenerating"))
      next  # Retry this iteration
    }
  
  X_data4 <- as.data.frame(X_data4)
  colnames(X_data4) <- c("X1", "X2")

  X_data4$X1 <- pmin(pmax(X_data4$X1, -1e6), 1e6)
  X_data4$X2 <- pmin(pmax(X_data4$X2, -1e6), 1e6)
  
  break 
  
}

  datasets_data4[[i]] <- list(X = X_data4, labels = true_labels_data4)
}

plot(datasets_data4[[1]]$X, col = datasets_data4[[1]]$labels, pch = 19, main = "Two concentric circles")
```
# Automated Model Evaluation

## Metric Calculation Function

```{r}
# Helper function to calculate metrics
  compute_metrics <- function(pred_labels, true_labels, X) {
    
    true_labels_int <- as.integer(as.factor(true_labels))
    pred_labels_int <- as.integer(as.factor(pred_labels))
  
    ari <- ARI(true_labels_int, pred_labels_int)
    extcrit <- extCriteria(pred_labels_int, true_labels_int, crit = c("Folkes_Mallows", "Jaccard"))
    fmi <- extcrit$folkes_mallows
    jci <- extcrit$jaccard
    nmi <- NMI(true_labels_int, pred_labels_int) # https://arxiv.org/pdf/1110.2515
    
    return(list(ARI = ari, FMI = fmi, JCI = jci, NMI = nmi))
  }
```

## Finding optimal epsilon values for DBSCAN (kNN)

```{r}
# Finding optimal eps values 
find_eps <- function(all_datasets, minPts = 4) {
  
  eps = list()
  
  for (dataset_name in names(all_datasets)) {
    eps[[dataset_name]] <- 0
  }
  
  for (dataset_name in names(all_datasets)) {
    cat("Finding eps for dataset:", dataset_name, "\n")
    
    runs = all_datasets[[dataset_name]]
    
    all_eps = list()
    
    for (i in seq_along(runs)) {
      X = runs[[i]]$X
      out = kNN(as.matrix(X), minPts)
    
      ds = out$dist[, minPts]
      
      ds_sorted = sort(ds)
  
      x <- 1:length(ds_sorted)
      y <- ds_sorted
  
      # ---------TRYING TO FIND ELBOW AUTOMATICALLY ---------
      
      # Line from first to last point
      line_vec <- c(tail(x, 1) - x[1], tail(y, 1) - y[1])
      line_vec <- line_vec / sqrt(sum(line_vec^2))  # normalize
  
      # Compute distances to the line
      vec_from_first <- cbind(x - x[1], y - y[1])
      scalar_proj <- vec_from_first %*% line_vec
      proj <- scalar_proj %*% t(line_vec)
      vec_to_line <- vec_from_first - proj
      dist_to_line <- sqrt(rowSums(vec_to_line^2))
  
      # Elbow index = max distance
      elbow_index <- which.max(dist_to_line)
      elbow_eps <- y[elbow_index]
      
      all_eps = append(all_eps, list(elbow_eps))
      
  #    Uncomment if you want to see the plots  
      plot(
        ds_sorted,
        type = "l",
        main = paste("Elbow Plot for", dataset_name, ";", length(unique(unlist(lapply(runs[[i]]$labels, levels)))), "Clusters"),
        xlab = "Points sorted by increasing radius",
        ylab = paste("Smallest radius containing", minPts, "NN")
      )   
    }
    
    eps[[dataset_name]] = mean(unlist(all_eps))
    
  }
  return(eps)
}

```

## Finding optimal epsilon values for DBSCAN (brutal)

```{r}

brutal_eps <- function(dataset_list) {
  eps_vals = seq(0, 1.5, length.out = 16)

  ari_for_eps = list()
  
  for (i in eps_vals){
    
    ari_list <- list()
    
    for (j in 1:20) {
      X = dataset_list[[j]]$X
      
      res <- dbscan::dbscan(X, eps = i, minPts = 4)
      
      dbscan_labels <- res$cluster

      metrics <- compute_metrics(dbscan_labels, dataset_list[[j]]$labels, X)
      
      ari_list <- c(ari_list, metrics$ARI)
      
    }
    
    ari_for_eps <- append(ari_for_eps, mean(unlist(ari_list)))
    
  }
  
  for (i in seq_along(ari_for_eps)) {
    cat("eps = ", i * 0.1, ": ARI = ", ari_for_eps[[i]], "|")
  }
  cat("\n")
}

brutal_eps(datasets_data3)
brutal_eps(datasets_data4)

```

## Model Fitting function

We created a function to run fits on all the models and calculate our chosen indices simultaneously.

```{r}
# Defining the comparison function
run_all_methods <- function(X, true_labels, dataset_name, true_k, plot_clusters = FALSE, e = 0.5) {
  
  methods_list <- c()
  k_list <- c()
  ari_list <- c()
  fmi_list <- c()
  jci_list <- c()
  nmi_list <- c()
  #silhouette_list <- c()
  runtime_list <- c()

  data_X <- as.data.frame(X)
  colnames(data_X) <- c("X1", "X2")
  
  # Helper function to record time
  measure_runtime <- function(expr) {
    start <- Sys.time()
    result <- eval(expr)
    end <- Sys.time()
    runtime <- as.numeric(difftime(end, start, units = "secs"))
    return(list(result = result, runtime = runtime))
  }

  ## ======================== K-MEANS ========================
  res <- measure_runtime(quote(kmeans(X, centers = true_k, nstart = 25)))
  kmeans_labels <- res$result$cluster
  
  metrics <- compute_metrics(kmeans_labels, true_labels, X)
  
  methods_list <- c(methods_list, "KMeans")
  k_list <- c(k_list, true_k)
  ari_list <- c(ari_list, metrics$ARI)
  fmi_list <- c(fmi_list, metrics$FMI)
  jci_list <- c(jci_list, metrics$JCI)
  nmi_list <- c(nmi_list, metrics$NMI)
  #silhouette_list <- c(silhouette_list, metrics$Silhouette)
  runtime_list <- c(runtime_list, res$runtime)
  
  if (plot_clusters) {
    print(fviz_cluster(list(data = data_X, cluster = kmeans_labels),
                 geom = "point", ellipse.type = "convex",
                 main = paste(dataset_name, "- KMeans")))
  }  
  
  ## ======================== Fuzzy Clustering ========================
  res <- measure_runtime(quote(PDQ(X, k = true_k)))
  fuzzy_labels <- res$result$label
  
  metrics <- compute_metrics(fuzzy_labels, true_labels, X)
  
  methods_list <- c(methods_list, "Fuzzy")
  k_list <- c(k_list, true_k)
  ari_list <- c(ari_list, metrics$ARI)
  fmi_list <- c(fmi_list, metrics$FMI)
  jci_list <- c(jci_list, metrics$JCI)
  nmi_list <- c(nmi_list, metrics$NMI)
  #silhouette_list <- c(silhouette_list, metrics$Silhouette)
  runtime_list <- c(runtime_list, res$runtime)
  
  if (plot_clusters) {
    print(fviz_cluster(list(data = data_X, cluster = fuzzy_labels),
                 geom = "point", ellipse.type = "convex",
                 main = paste(dataset_name, "- Fuzzy Clustering")))
  }  
  ## ======================== GMM ========================
  res <- measure_runtime(quote(Mclust(X, G = true_k, modelNames = "VVV")))
  gmm_labels <- res$result$classification
  
  metrics <- compute_metrics(gmm_labels, true_labels, X)
  
  methods_list <- c(methods_list, "GMM")
  k_list <- c(k_list, true_k)
  ari_list <- c(ari_list, metrics$ARI)
  fmi_list <- c(fmi_list, metrics$FMI)
  jci_list <- c(jci_list, metrics$JCI)
  nmi_list <- c(nmi_list, metrics$NMI)
  #silhouette_list <- c(silhouette_list, metrics$Silhouette)
  runtime_list <- c(runtime_list, res$runtime)
  
  if (plot_clusters) {
    print(fviz_cluster(list(data = data_X, cluster = gmm_labels),
                 geom = "point", ellipse.type = "convex",
                 main = paste(dataset_name, "- GMM")))
  }  
  
  ## ======================== Spectral Clustering ========================
  res <- measure_runtime(quote(specc(as.matrix(X), centers = true_k)))
  spectral_labels <- as.numeric(res$result)
  
  metrics <- compute_metrics(spectral_labels, true_labels, X)
  
  methods_list <- c(methods_list, "Spectral")
  k_list <- c(k_list, true_k)
  ari_list <- c(ari_list, metrics$ARI)
  fmi_list <- c(fmi_list, metrics$FMI)
  jci_list <- c(jci_list, metrics$JCI)
  nmi_list <- c(nmi_list, metrics$NMI)
  #silhouette_list <- c(silhouette_list, metrics$Silhouette)
  runtime_list <- c(runtime_list, res$runtime)
  
  if (plot_clusters) {
    print(fviz_cluster(list(data = data_X, cluster = spectral_labels),
                 geom = "point", ellipse.type = "convex",
                 main = paste(dataset_name, "- Spectral Clustering")))
  }  
  ## ======================== DBSCAN ========================
  eps_val <- e # Hard-coded becuase it has the best performance 
  minPts_val <- 4 # 2 x dim 
  
  res <- measure_runtime(quote(dbscan::dbscan(X, eps = eps_val, minPts = minPts_val)))
  dbscan_labels <- res$result$cluster
  
  metrics <- compute_metrics(dbscan_labels, true_labels, X)
  
  methods_list <- c(methods_list, "DBSCAN")
  k_list <- c(k_list, NA)  # DBSCAN doesn't need k
  ari_list <- c(ari_list, metrics$ARI)
  fmi_list <- c(fmi_list, metrics$FMI)
  jci_list <- c(jci_list, metrics$JCI)
  nmi_list <- c(nmi_list, metrics$NMI)
  #silhouette_list <- c(silhouette_list, metrics$Silhouette)
  runtime_list <- c(runtime_list, res$runtime)
  
  valid_idx <- which(!is.na(dbscan_labels) & dbscan_labels != 0)
  plot_data <- X[valid_idx, , drop = FALSE]
  plot_labels <- dbscan_labels[valid_idx]
  
  if (plot_clusters) {
    print(fviz_cluster(list(data = plot_data, cluster = plot_labels),
                 geom = "point", ellipse.type = "convex",
                 main = paste(dataset_name, "- DBSCAN")))
  }  
  
  ## ======================== Results Table ========================
  results <- data.frame(
    Method = methods_list,
    K = k_list,
    ARI = ari_list,
    FMI = fmi_list,
    JCI = jci_list,
    NMI = nmi_list,
    #Silhouette = silhouette_list,
    Runtime_sec = runtime_list
  )
  
  return(results)
}

```

# Model Training and Evaluation

## Plotting examples from each dataset group

```{r}
# List of all datasets
all_datasets <- list(
  "Spherical" = datasets_data1,
  "Overlapping" = datasets_data2,
  "MoonsBlob" = datasets_data3,
  "ConcentricCircles" = datasets_data4
)

# True number of clusters for each dataset
true_k_list <- list(
  "Spherical" = 3,
  "Overlapping" = 3,
  "MoonsBlob" = 3,
  "ConcentricCircles" = 2
)

# ---- Plot for only 1 run per dataset ----
for (dataset_name in names(all_datasets)) {
  cat("Plotting for dataset:", dataset_name, "\n")
  
  # Get only the FIRST RUN of this dataset
  X <- all_datasets[[dataset_name]][[1]]$X
  labels <- all_datasets[[dataset_name]][[1]]$labels
  true_k <- true_k_list[[dataset_name]]
  
  # Plot all methods for this dataset and first run
  run_all_methods(X, labels, dataset_name, true_k, plot_clusters = TRUE)
}

all_results <- list()
```
```{r}
eps = find_eps(all_datasets)
```

## Running fits and analysis for each dataset and averaging indices

### Skip the next three cells if you want to save some time (can take ~30-40 mins to run)

```{r}
# Loop over datasets
for (dataset_name in names(all_datasets)) {
  cat("Running for dataset:", dataset_name, "\n")
  
  dataset_runs <- all_datasets[[dataset_name]]
  true_k <- true_k_list[[dataset_name]]
  
  dataset_results <- list()
  
  for (i in seq_along(dataset_runs)) {
    cat("  Run", i, "\n")
    
    X <- dataset_runs[[i]]$X
    labels <- dataset_runs[[i]]$labels
    
    res <- run_all_methods(X, labels, dataset_name, true_k, plot_clusters = FALSE)
    
    # Add an ID for run tracking
    res$Dataset <- dataset_name
    res$Run <- i
    
    dataset_results[[i]] <- res
  }
  
  # Bind all runs for this dataset
  all_results[[dataset_name]] <- do.call(rbind, dataset_results)
}

# Combine everything into a single big dataframe
final_results <- do.call(rbind, all_results)

```

```{r}
# print output to console 
final_results
```

```{r}
#printing summary of results to console 
library(dplyr)

summary_results <- final_results %>%
  group_by(Dataset, Method) %>%
  summarise(
    mean_ARI = mean(ARI, na.rm = TRUE),
    sd_ARI = sd(ARI, na.rm = TRUE),
    mean_FMI = mean(FMI, na.rm = TRUE),
    mean_JCI = mean(JCI, na.rm = TRUE),
    mean_NMI = mean(NMI, na.rm = TRUE),
    mean_Runtime = mean(Runtime_sec, na.rm = TRUE),
    .groups = "drop"
  )

print(summary_results, n=Inf)

summary_results %>%
  select(Dataset, Method, mean_Runtime) %>%
  print(n = Inf)

```

# Scaling the Data

After acquiring results from 2D datasets with a small number of clusters, we wanted to test the scalability of our algorithms by increasing the number of clusters to five for all dataset styles.

```{r}
# Create empty lists to store datasets
datasets_data5 <- list()
datasets_data6 <- list()
datasets_data7 <- list()
datasets_data8 <- list()
datasets_data9 <- list()
```

```{r}
# Number of repetitions
n_reps <- 20
```

## Dataset 5: Well-separated spherical clusters

```{r}
for (i in 1:n_reps) {
  repeat{
  n <- 200
  p <- 2
  mu1 <- c(0, 0)
  mu2 <- c(3, 3)
  mu3 <- c(5, 0)
  mu4 <- c(8, 3)
  mu5 <- c(10, 0)
  Sigma <- diag(2) * 0.5
  
  cluster1 <- mvrnorm(n, mu1, Sigma)
  cluster2 <- mvrnorm(n, mu2, Sigma)
  cluster3 <- mvrnorm(n, mu3, Sigma)
  cluster4 <- mvrnorm(n, mu4, Sigma)
  cluster5 <- mvrnorm(n, mu5, Sigma)
  
  X_data5 <- rbind(cluster1, cluster2, cluster3, cluster4, cluster5)
  true_labels_data5 <- factor(rep(1:5, each = n))
  
  # Check if dataset is clean
    if (any(!is.finite(as.matrix(X_data5))) || any(is.na(as.matrix(X_data5))) || any(is.nan(as.matrix(X_data5)))) {
      warning(paste("Non-finite values detected in Well-separated spherical dataset run", i, "- regenerating"))
      next  # Retry this iteration
    }
  
  X_data5 <- as.data.frame(X_data5)
  colnames(X_data5) <- c("X1", "X2")

  X_data5$X1 <- pmin(pmax(X_data5$X1, -1e6), 1e6)
  X_data5$X2 <- pmin(pmax(X_data5$X2, -1e6), 1e6)
  
  
  break 
  
  }
  
  datasets_data5[[i]] <- list(X = X_data5, labels = true_labels_data5)
}

plot(datasets_data5[[1]]$X, col = datasets_data5[[1]]$labels, pch = 19, main = "Well-separated spherical clusters")
```

## Dataset 6: Overlapping spherical clusters

```{r}
for (i in 1:n_reps) {
  repeat{
  n <- 200
  p <- 2
  mu1 <- c(2, 2)
  mu2 <- c(5, 3)
  mu3 <- c(3, 5)
  mu4 <- c(8, 3)
  mu5 <- c(6, 7)
  Sigma <- diag(2) * 1.2
  
  cluster1 <- mvrnorm(n, mu1, Sigma)
  cluster2 <- mvrnorm(n, mu2, Sigma)
  cluster3 <- mvrnorm(n, mu3, Sigma)
  cluster4 <- mvrnorm(n, mu4, Sigma)
  cluster5 <- mvrnorm(n, mu5, Sigma)
  
  X_data6 <- rbind(cluster1, cluster2, cluster3, cluster4, cluster5)
  true_labels_data6 <- factor(rep(1:5, each = n))
  
  # Check if dataset is clean
    if (any(!is.finite(as.matrix(X_data6))) || any(is.na(as.matrix(X_data6))) || any(is.nan(as.matrix(X_data6)))) {
      warning(paste("Non-finite values detected in overlapping spherical dataset run", i, "- regenerating"))
      next  # Retry this iteration
    }
  
  X_data6 <- as.data.frame(X_data6)
  colnames(X_data6) <- c("X1", "X2")

  X_data6$X1 <- pmin(pmax(X_data6$X1, -1e6), 1e6)
  X_data6$X2 <- pmin(pmax(X_data6$X2, -1e6), 1e6)
  
  
  break 
  
  }
  
  datasets_data6[[i]] <- list(X = X_data6, labels = true_labels_data6)
}

plot(datasets_data6[[1]]$X, col = datasets_data6[[1]]$labels, pch = 19, main = "Overlapping spherical clusters")
```

## Dataset 7: Moons + shifted blob + slashes (non-convex + convex)

We added two new types of clusters while scaling this data up; slashes generated by adding random normal noise around lines.

```{r}
for (i in 1:n_reps) {
  repeat{
  n_core <- 200
  n_outliers_per_cluster <- 2
  theta <- runif(n_core, 0, pi)
  
  # Moon 1
  x1 <- cos(theta) + rnorm(n_core, sd = 0.05)
  y1 <- sin(theta) + rnorm(n_core, sd = 0.05)
  moon1_core <- cbind(x1, y1)
  
  theta_out1 <- runif(n_outliers_per_cluster, 0, pi)
  x1_out <- cos(theta_out1) * 2 + rnorm(n_outliers_per_cluster, sd = 0.2)
  y1_out <- sin(theta_out1) * 2 + rnorm(n_outliers_per_cluster, sd = 0.2)
  moon1_outliers <- cbind(x1_out, y1_out)
  
  # Moon 2
  x2 <- 1 - cos(theta) + rnorm(n_core, sd = 0.05)
  y2 <- -sin(theta) - 0.3 + rnorm(n_core, sd = 0.05)
  moon2_core <- cbind(x2, y2)
  
  theta_out2 <- runif(n_outliers_per_cluster, 0, pi)
  x2_out <- (1 - cos(theta_out2)) * 2 + rnorm(n_outliers_per_cluster, sd = 0.2)
  y2_out <- (-sin(theta_out2) - 0.3) * 2 + rnorm(n_outliers_per_cluster, sd = 0.2)
  moon2_outliers <- cbind(x2_out, y2_out)
  
  # Circle blob
  circle_center <- c(3, 2)
  circle_core <- mvrnorm(n_core, mu = circle_center, Sigma = diag(2) * 0.1)
  circle_outliers <- mvrnorm(n_outliers_per_cluster, mu = circle_center + c(1.5, 1.5), Sigma = diag(2) * 0.1)
  
  # Slash 1 (rising line like \) 
  x3 <- runif(n_core, min = 4, max = 7)
  y3 <- (x3 - 5) + rnorm(n_core, sd = 0.05)  
  slash1_core <- cbind(x3, y3)
  
  # Slash 2 (falling line like /)
  x4 <- runif(n_core, min = 4, max = 7)
  y4 <- -(x4 - 5) -4 + rnorm(n_core, sd = 0.05) 
  slash2_core <- cbind(x4, y4)  
  
  # Combine all
  X <- rbind(
    moon1_core,
    moon2_core,
    circle_core,
    slash1_core,
    slash2_core,
    moon1_outliers,
    moon2_outliers,
    circle_outliers
  )
  
  labels <- factor(c(
    rep(1, n_core + n_outliers_per_cluster),
    rep(2, n_core + n_outliers_per_cluster),
    rep(3, n_core + n_outliers_per_cluster),
    rep(4, n_core), 
    rep(5, n_core) 
  ))
  
  # Check if dataset is clean
    if (any(!is.finite(as.matrix(X))) || any(is.na(as.matrix(X))) || any(is.nan(as.matrix(X)))) {
      warning(paste("Non-finite values detected in moons + shifted blob dataset run", i, "- regenerating"))
      next  # Retry this iteration
    }
  
  X <- as.data.frame(X)
  colnames(X) <- c("X1", "X2")

  X$X1 <- pmin(pmax(X$X1, -1e6), 1e6)
  X$X2 <- pmin(pmax(X$X2, -1e6), 1e6)
  
  
  break 
  
  }
  
  datasets_data7[[i]] <- list(X = X, labels = labels)
}

plot(datasets_data7[[1]]$X, col = datasets_data7[[1]]$labels, pch = 19, main = "Moons + shifted blob (non-convex + convex)")
```

## Dataset 8: Five concentric circles

```{r}
for (i in 1:n_reps) {
  repeat{
  n <- 300  # points per circle
  
  # Circle 1 (smaller)
  theta1 <- runif(n, 0, 2*pi)
  r1 <- 1
  x1 <- r1 * cos(theta1) + rnorm(n, 0, 0.05)
  y1 <- r1 * sin(theta1) + rnorm(n, 0, 0.05)
  
  # Circle 2 (larger)
  theta2 <- runif(n, 0, 2*pi)
  r2 <- 2
  x2 <- r2 * cos(theta2) + rnorm(n, 0, 0.05)
  y2 <- r2 * sin(theta2) + rnorm(n, 0, 0.05)

  theta3 <- runif(n, 0, 2*pi)
  r3 <- 3
  x3 <- r3 * cos(theta3) + rnorm(n, 0, 0.05)
  y3 <- r3 * sin(theta3) + rnorm(n, 0, 0.05)
    
  theta4 <- runif(n, 0, 2*pi)
  r4 <- 4
  x4 <- r4 * cos(theta4) + rnorm(n, 0, 0.05)
  y4 <- r4 * sin(theta4) + rnorm(n, 0, 0.05)
    
  X_data8 <- data.frame(X1 = c(x1, x2, x3, x4), X2 = c(y1, y2, y3, y4))
  true_labels_data8 <- factor(c(rep(1, n), rep(2, n), rep(3, n), rep(4, n)))
  
  # Check if dataset is clean
    if (any(!is.finite(as.matrix(X_data8))) || any(is.na(as.matrix(X_data8))) || any(is.nan(as.matrix(X_data8)))) {
      warning(paste("Non-finite values detected in concentric circles dataset run", i, "- regenerating"))
      next  # Retry this iteration
    }
  
  X_data8 <- as.data.frame(X_data8)
  colnames(X_data8) <- c("X1", "X2")

  X_data8$X1 <- pmin(pmax(X_data8$X1, -1e6), 1e6)
  X_data8$X2 <- pmin(pmax(X_data8$X2, -1e6), 1e6)
  
  break 
  
}

  datasets_data8[[i]] <- list(X = X_data8, labels = true_labels_data8)
}

plot(datasets_data8[[1]]$X, col = datasets_data8[[1]]$labels, pch = 19, main = "Four concentric circles")
```

## Dataset 9: Moons + shifted blob + slashes (non-convex + convex) - 10D

As a final test, we scaled the dimensions up to 10 while retaining 5 clusters. The "moons" were curved in multiple dimensions as well in order to add more complexity to the clusters.

```{r}
n_reps <- 20

for (j in 1:n_reps) {
  repeat{
    n_core = 200
    n_outliers_per_cluster = 5
    d = 10 # Num dims
    theta = runif(n_core, 0, pi)
    
    # --- Moons ---
    
    # initialize emtpy matrix
    moon1_core <- matrix(0, nrow = n_core, ncol = d)
    
    # first four dimensions are crescents
    moon1_core[,1] <- cos(theta) + rnorm(n_core, sd = 0.05)
    moon1_core[,2] <- sin(theta) + rnorm(n_core, sd = 0.05)
    moon1_core[,3] <- cos(2*theta) + rnorm(n_core, sd = 0.05)
    moon1_core[,4] <- sin(2*theta) + rnorm(n_core, sd = 0.05)
    
    # rest are random noise
    moon1_core[,5:10] <- matrix(rnorm(n_core * 6, sd = 0.05), ncol = 6)
    
    # repeated for second moon
    
    moon2_core <- matrix(0, nrow = n_core, ncol = d)
    
    moon2_core[,1] <- 1 - cos(theta) + rnorm(n_core, sd = 0.05)
    moon2_core[,2] <- -sin(theta) - 0.3 + rnorm(n_core, sd = 0.05)
    moon2_core[,3] <- 1 - cos(2*theta) + rnorm(n_core, sd = 0.05)
    moon2_core[,4] <- -sin(2*theta) - 0.3 + rnorm(n_core, sd = 0.05)
    
    moon2_core[,5:10] <- matrix(rnorm(n_core * 6, sd = 0.05), ncol = 6)
    
    # Outliers for moons
    theta_out1 <- runif(n_outliers_per_cluster, 0, pi)
    theta_out2 <- runif(n_outliers_per_cluster, 0, pi)
    
    moon1_outliers <- matrix(rnorm(n_outliers_per_cluster * d, sd = 0.2), ncol = d)
    moon1_outliers[,1] <- cos(theta_out1) * 2 + rnorm(n_outliers_per_cluster, sd = 0.2)
    moon1_outliers[,2] <- sin(theta_out1) * 2 + rnorm(n_outliers_per_cluster, sd = 0.2)
    
    moon2_outliers <- matrix(rnorm(n_outliers_per_cluster * d, sd = 0.2), ncol = d)
    moon2_outliers[,1] <- (1 - cos(theta_out2)) * 2 + rnorm(n_outliers_per_cluster, sd = 0.2)
    moon2_outliers[,2] <- (-sin(theta_out2) - 0.3) * 2 + rnorm(n_outliers_per_cluster, sd = 0.2)
    
    #### ---- Sphere ----
    sphere_center <- rep(1.5, d)
    sphere_core <- mvrnorm(n_core, mu = sphere_center, Sigma = diag(d) * 0.1)
    sphere_outliers <- mvrnorm(n_outliers_per_cluster, mu = sphere_center + 1.5, Sigma = diag(d) * 0.1)
    
    #### ---- Slashes ----
    # Random directions in 10D
    direction1 <- rnorm(d)
    direction1 <- direction1 / sqrt(sum(direction1^2))  # normalize
    
    direction2 <- rnorm(d)
    direction2 <- direction2 / sqrt(sum(direction2^2))  # normalize
    
    # Slashes
    t1 <- runif(n_core, min = -5, max = 5)
    slash1_core <- matrix(rnorm(n_core * d, sd = 0.05), ncol = d)
    for (i in 1:d) {
      slash1_core[,i] <- slash1_core[,i] + direction1[i] * t1
    }
    
    t2 <- runif(n_core, min = -5, max = 5)
    slash2_core <- matrix(rnorm(n_core * d, sd = 0.05), ncol = d)
    for (i in 1:d) {
      slash2_core[,i] <- slash2_core[,i] + direction2[i] * t2
    }
    
    X <- rbind(
      moon1_core,
      moon1_outliers,
      moon2_core,
      moon2_outliers,
      sphere_core,
      sphere_outliers,
      slash1_core,
      slash2_core
    )
    
    labels <- factor(c(
      rep(1, n_core + n_outliers_per_cluster),
      rep(2, n_core + n_outliers_per_cluster),
      rep(3, n_core + n_outliers_per_cluster),
      rep(4, n_core),
      rep(5, n_core)
    ))

    # Check if dataset is clean
    if (any(!is.finite(X)) || any(is.na(X)) || any(is.nan(X))) {
      warning(paste("Non-finite values detected in concentric circles dataset run", i, "- regenerating"))
      next  # Retry this iteration
    }
    
    X <- as.data.frame(X)
    colnames(X) <- c("X1", "X2", "X3", "X4", "X5", "X6", "X7", "X8", "X9", "X10")

    X$X1 <- pmin(pmax(X$X1, -1e6), 1e6)
    X$X2 <- pmin(pmax(X$X2, -1e6), 1e6)
    X$X3 <- pmin(pmax(X$X3, -1e6), 1e6)
    X$X4 <- pmin(pmax(X$X4, -1e6), 1e6)
    X$X5 <- pmin(pmax(X$X5, -1e6), 1e6)
    X$X6 <- pmin(pmax(X$X6, -1e6), 1e6)
    X$X7 <- pmin(pmax(X$X7, -1e6), 1e6)
    X$X8 <- pmin(pmax(X$X8, -1e6), 1e6)
    X$X9 <- pmin(pmax(X$X9, -1e6), 1e6)
    X$X10 <- pmin(pmax(X$X10, -1e6), 1e6)
    
    break
    
  }
  
  datasets_data9[[j]] <- list(X = X, labels = labels)
  
}

#### ---- Visualize with t-SNE ----
  tsne_out <- Rtsne(datasets_data9[[10]]$X, dims = 2, perplexity = 30)
  tsne_df <- data.frame(
    X1 = tsne_out$Y[,1],
    X2 = tsne_out$Y[,2],
    label = datasets_data9[[10]]$labels
  )
  
  ggplot(tsne_df, aes(X1, X2, color = label)) +
    geom_point(size = 1.5) +
    ggtitle("t-SNE Projection of 10D Complex Clusters") +
    theme_minimal()
```

# Model Training and Evaluation (Scaled, 2D)

## Plotting examples from each dataset (Scaled, 2D)

```{r}
# List of all datasets
all_datasets_2 <- list(
  "Spherical" = datasets_data5,
  "Overlapping" = datasets_data6,
  "MoonsBlob" = datasets_data7,
  "ConcentricCircles" = datasets_data8
)

# True number of clusters for each dataset
true_k_list_2 <- list(
  "Spherical" = 5,
  "Overlapping" = 5,
  "MoonsBlob" = 5,
  "ConcentricCircles" = 4
)

# ---- Plot for only 1 run per dataset ----
for (dataset_name in names(all_datasets_2)) {
  cat("Plotting for dataset:", dataset_name, "\n")
  
  # Get only the FIRST RUN of this dataset
  X <- all_datasets_2[[dataset_name]][[1]]$X
  labels <- all_datasets_2[[dataset_name]][[1]]$labels
  true_k <- true_k_list_2[[dataset_name]]
  
  # Plot all methods for this dataset and first run
  run_all_methods(X, labels, dataset_name, true_k, plot_clusters = TRUE)
}

all_results_2 <- list()
```

## Running fits and analysis for each dataset and averaging indices (Scaled, 2D)

### Skip the next three cells if you want to save time (can take ~30-40 mins to run)

```{r}
# Loop over datasets
for (dataset_name in names(all_datasets_2)) {
  cat("Running for dataset:", dataset_name, "\n")
  
  dataset_runs <- all_datasets_2[[dataset_name]]
  true_k <- true_k_list_2[[dataset_name]]
  
  dataset_results <- list()
  
  for (i in seq_along(dataset_runs)) {
    cat("  Run", i, "\n")
    
    X <- dataset_runs[[i]]$X
    labels <- dataset_runs[[i]]$labels
    
    res <- run_all_methods(X, labels, dataset_name, true_k, plot_clusters = FALSE)
    
    # Add an ID for run tracking
    res$Dataset <- dataset_name
    res$Run <- i
    
    dataset_results[[i]] <- res
  }
  
  # Bind all runs for this dataset
  all_results_2[[dataset_name]] <- do.call(rbind, dataset_results)
}

# Combine everything into a single big dataframe
final_results_2 <- do.call(rbind, all_results_2)

```

```{r}
#printing final results to console
final_results_2

```

```{r}
# printing summary to console
library(dplyr)

summary_results_2 <- final_results_2 %>%
  group_by(Dataset, Method) %>%
  summarise(
    mean_ARI = mean(ARI, na.rm = TRUE),
    sd_ARI = sd(ARI, na.rm = TRUE),
    mean_FMI = mean(FMI, na.rm = TRUE),
    mean_JCI = mean(JCI, na.rm = TRUE),
    mean_NMI = mean(NMI, na.rm = TRUE),
    mean_Runtime = mean(Runtime_sec, na.rm = TRUE),
    .groups = "drop"
  )

print(summary_results_2, n=Inf)

summary_results_2 %>%
  select(Dataset, Method, mean_Runtime) %>%
  print(n = Inf)

```

# Model Training and Evaluation (Scaled, 10D)

## Finding appropriate eps value for DBSCAN

```{r}
brutal_eps(datasets_data9)
```
The above code found that optimal eps is roughly 0.4. 

## Plotting an example (Scaled, 10D)

```{r}
# List of all datasets
all_datasets_3 <- list(
  "MoonsBlob-10D" = datasets_data9
)

# True number of clusters for each dataset
true_k_list_3 <- list(
  "MoonsBlob-10D" = 5
)

# ---- Plot for only 1 run per dataset ----
for (dataset_name in names(all_datasets_3)) {
  cat("Plotting for dataset:", dataset_name, "\n")
  
  # Get only the FIRST RUN of this dataset
  X <- all_datasets_3[[dataset_name]][[1]]$X
  labels <- all_datasets_3[[dataset_name]][[1]]$labels
  true_k <- true_k_list_3[[dataset_name]]
  
  # Plot all methods for this dataset and first run
  run_all_methods(X, labels, dataset_name, true_k, plot_clusters = TRUE, e = 0.4)
}

all_results_3 <- list()
```

## Analysis for all runs (Scaled, 10D)

### Skip the next 3 cells to save some time (can take ~30-40 mins to run)

```{r}
# Loop over datasets
for (dataset_name in names(all_datasets_3)) {
  cat("Running for dataset:", dataset_name, "\n")
  
  dataset_runs <- all_datasets_3[[dataset_name]]
  true_k <- true_k_list_3[[dataset_name]]
  
  dataset_results <- list()
  
  for (i in seq_along(dataset_runs)) {
    cat("  Run", i, "\n")
    
    X <- dataset_runs[[i]]$X
    labels <- dataset_runs[[i]]$labels
    
    res <- run_all_methods(X, labels, dataset_name, true_k, plot_clusters = FALSE)
    
    # Add an ID for run tracking
    res$Dataset <- dataset_name
    res$Run <- i
    
    dataset_results[[i]] <- res
  }
  
  # Bind all runs for this dataset
  all_results_3[[dataset_name]] <- do.call(rbind, dataset_results)
}

# Combine everything into a single big dataframe
final_results_3 <- do.call(rbind, all_results_3)

```

```{r}
# Printing output to console
final_results_3

```

```{r}
# printing summary to console
library(dplyr)

summary_results_3 <- final_results_3 %>%
  group_by(Dataset, Method) %>%
  summarise(
    mean_ARI = mean(ARI, na.rm = TRUE),
    sd_ARI = sd(ARI, na.rm = TRUE),
    mean_FMI = mean(FMI, na.rm = TRUE),
    mean_JCI = mean(JCI, na.rm = TRUE),
    mean_NMI = mean(NMI, na.rm = TRUE),
    mean_Runtime = mean(Runtime_sec, na.rm = TRUE),
    .groups = "drop"
  )

print(summary_results_3, n=Inf)

summary_results_3 %>%
  select(Dataset, Method, mean_Runtime) %>%
  print(n = Inf)

```
